Dựa trên dự án hiện tại sử dụng **NestJS** với **TypeORM** và cơ sở dữ liệu **PostgreSQL**, đã có sẵn `User` entity, **JWT** cho quản lý access token/refresh token, bảo vệ **CSRF**, và **Swagger** để quản lý API, hãy triển khai tính năng đăng nhập xã hội bằng Google và Facebook với các yêu cầu sau:

1. **Tích hợp đăng nhập bằng Google và Facebook**:
   - Sử dụng giao thức **OAuth 2.0** để triển khai đăng nhập qua Google và Facebook trong ứng dụng NestJS.
   - Sử dụng thư viện `@nestjs/passport` với chiến lược `passport-google-oauth20` (cho Google) và `passport-facebook` (cho Facebook) để xử lý luồng xác thực.
   - Cấu hình các endpoint REST:
     - `GET /auth/google` và `GET /auth/google/callback` cho đăng nhập Google.
     - `GET /auth/facebook` và `GET /auth/facebook/callback` cho đăng nhập Facebook.
   - Tích hợp nút đăng nhập Google và Facebook trên giao diện người dùng (giả định frontend đã có), tuân theo hướng dẫn thiết kế của **Google Sign-In** và **Facebook Login**.

2. **Cập nhật và quản lý `User` entity**:
   - Kiểm tra `User` entity hiện tại và thêm các trường cần thiết (nếu chưa có) để hỗ trợ đăng nhập xã hội:
     - `provider` (enum: `google`, `facebook`, `local`, để xác định nguồn đăng nhập).
     - `providerId` (string, lưu ID duy nhất từ Google/Facebook).
   - Sau khi người dùng đăng nhập thành công qua Google hoặc Facebook:
     - Kiểm tra xem người dùng đã tồn tại trong bảng `User` dựa trên `email` hoặc `providerId`:
       - Nếu chưa tồn tại, tạo bản ghi mới với thông tin từ Google/Facebook (email, tên, provider, providerId, avatar).
       - Nếu tồn tại, cập nhật thông tin (nếu cần, ví dụ: avatar, name) và trả về thông tin người dùng.
     - Xử lý trường hợp email trùng lặp (cùng email nhưng khác provider) bằng cách:
       - Hợp nhất tài khoản (liên kết provider mới với user hiện có) hoặc trả về lỗi yêu cầu người dùng xác nhận.
   - Đảm bảo các giao dịch với cơ sở dữ liệu được xử lý an toàn thông qua TypeORM.

3. **Tích hợp với JWT và refresh token**:
   - Sau khi đăng nhập thành công, tạo **JWT access token** và **refresh token** (tương tự cơ chế hiện tại) sử dụng `@nestjs/jwt`.
   - Lưu refresh token vào cơ sở dữ liệu (trong `User` hoặc bảng riêng như `RefreshToken` nếu đã có).
   - Trả về access token và refresh token trong response của các endpoint `/auth/google/callback` và `/auth/facebook/callback`.
   - Đảm bảo người dùng có thể truy cập lại các sự kiện (events) liên kết với tài khoản của họ sau khi đăng nhập lại, kể cả khi access token hết hạn (sử dụng refresh token để làm mới).

4. **Tích hợp với `Event` entity**:
   - Đảm bảo các sự kiện hiện có (cuộc hẹn/lời nhắc nhở) được liên kết với người dùng thông qua `userId` trong `Event` entity.
   - Khi người dùng đăng nhập lại (bằng Google, Facebook, hoặc cùng email qua provider khác), các sự kiện của họ được khôi phục thông qua các endpoint hiện có (ví dụ: `GET /events`).
   - Không cần tạo mới `Event` entity, chỉ cần đảm bảo tính năng đăng nhập mới không làm gián đoạn việc truy xuất sự kiện.

5. **Bảo mật**:
   - Tích hợp với cơ chế **CSRF** hiện có để bảo vệ các endpoint `/auth/*`.
   - Xác minh tính hợp lệ của token từ Google/Facebook (kiểm tra issuer, audience, v.v.) trước khi xử lý

6. **Xử lý lỗi và trải nghiệm người dùng**:
   - Trả về mã lỗi HTTP và message rõ ràng trong các trường hợp:
     - `400 Bad Request`: Token không hợp lệ hoặc thông tin không đầy đủ.
     - `409 Conflict`: Email trùng lặp cần xác nhận hợp nhất tài khoản.
     - `401 Unauthorized`: Xác thực thất bại.
   - Sử dụng **NestJS Exception Filters** để xử lý lỗi tập trung từ OAuth hoặc TypeORM.
   - Đảm bảo frontend hiển thị thông báo lỗi thân thiện (ví dụ: "Đăng nhập thất bại, vui lòng thử lại").
   - Hỗ trợ đăng nhập liền mạch trên desktop và mobile.

7. **Tích hợp với Swagger**:
   - Cập nhật tài liệu API trong **Swagger** (sử dụng `@nestjs/swagger`) để mô tả các endpoint mới:
     - `GET /auth/google`, `GET /auth/google/callback`.
     - `GET /auth/facebook`, `GET /auth/facebook/callback`.
   - Bao gồm mô tả, tham số, và các response mẫu (thành công/lỗi) cho từng endpoint.

8. **Kiểm thử**:
   - Viết **unit tests** sử dụng **Jest** để kiểm tra:
     - Luồng đăng nhập Google/Facebook.
     - Lưu trữ và cập nhật `User` trong PostgreSQL.
     - Xử lý lỗi (token không hợp lệ, email trùng lặp).
   - Kiểm tra trường hợp biên như đăng nhập thất bại, access token hết hạn, hoặc email trùng lặp.

9. **Tài liệu hóa**:
   - Cập nhật tài liệu Swagger với các endpoint mới.
   - Ghi lại cách cấu hình Google/Facebook OAuth (Client ID, Client Secret, Callback URL) trong file `.env` của NestJS, ví dụ:
     ```
     GOOGLE_CLIENT_ID=your-google-client-id
     GOOGLE_CLIENT_SECRET=your-google-client-secret
     GOOGLE_CALLBACK_URL=http://localhost:3000/auth/google/callback
     FACEBOOK_CLIENT_ID=your-facebook-client-id
     FACEBOOK_CLIENT_SECRET=your-facebook-client-secret
     FACEBOOK_CALLBACK_URL=http://localhost:3000/auth/facebook/callback
     ```
   - Mô tả các thay đổi (nếu có) trong `User` entity và cách tích hợp với hệ thống hiện có.

**Yêu cầu bổ sung**:
- Sử dụng các module trong NestJS (ví dụ: `AuthModule`, `UsersModule`) để tổ chức mã nguồn rõ ràng, tích hợp với các module hiện có.
- Đảm bảo mã tuân thủ các nguyên tắc **SOLID** và sử dụng **Dependency Injection** của NestJS.
- Cấu hình **CORS** (nếu cần) để hỗ trợ frontend.
- Nếu cần thêm nhà cung cấp đăng nhập (như Twitter) hoặc tích hợp thông báo cho sự kiện, vui lòng cho biết.

**Ví dụ cập nhật `User` entity** (nếu cần thêm trường):
```typescript
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column({ nullable: true })
  name: string;

  @Column({ type: 'enum', enum: ['google', 'facebook', 'local'], default: 'local' })
  provider: string;

  @Column({ nullable: true })
  providerId: string;

  @Column({ nullable: true })
  avatar: string;

  @Column({ nullable: true })
  refreshToken: string; // Assuming refresh token is stored here

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

**Ví dụ triển khai endpoint Google Auth**:
```typescript
import { Controller, Get, UseGuards, Req, Res } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { AuthService } from './auth.service';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { Response } from 'express';

@ApiTags('auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Get('google')
  @UseGuards(AuthGuard('google'))
  @ApiOperation({ summary: 'Initiate Google OAuth login' })
  async googleLogin() {
    // Handled by Passport
  }

  @Get('google/callback')
  @UseGuards(AuthGuard('google'))
  @ApiOperation({ summary: 'Google OAuth callback' })
  @ApiResponse({ status: 200, description: 'Returns JWT tokens' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async googleLoginCallback(@Req() req, @Res() res: Response) {
    const tokens = await this.authService.handleSocialLogin(req.user);
    res.json(tokens);
  }
}
```