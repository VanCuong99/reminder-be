import { Test, TestingModule } from '@nestjs/testing';
import { DeviceFingerprintingService } from '../../shared/services/device-fingerprinting.service';
import { EventEnrichmentService } from '../../shared/services/event-enrichment.service';
import { BadRequestException, Logger } from '@nestjs/common';
import { Response } from 'express';
import { GuestEventController } from './guest-event.controller';
import { EventService } from '../../application/services/events/event.service';
import { TimezoneService } from '../../shared/services/timezone.service';
import { CreateEventDto } from '../dto/event/create-event.dto';
import { EventCategory } from '../../domain/entities/event.entity';
import { RegisterDeviceDto } from '../dto/guest/register-device.dto';
import { GuestDeviceService } from '../../application/services/guest-device/guest-device.service';

describe('GuestEventController', () => {
    // Silence all logger output for all tests
    let loggerErrorSpy: jest.SpyInstance;
    let loggerDebugSpy: jest.SpyInstance;
    let loggerWarnSpy: jest.SpyInstance;
    let loggerLogSpy: jest.SpyInstance;
    beforeAll(() => {
        loggerErrorSpy = jest.spyOn(Logger.prototype, 'error').mockImplementation(() => {});
        loggerDebugSpy = jest.spyOn(Logger.prototype, 'debug').mockImplementation(() => {});
        loggerWarnSpy = jest.spyOn(Logger.prototype, 'warn').mockImplementation(() => {});
        loggerLogSpy = jest.spyOn(Logger.prototype, 'log').mockImplementation(() => {});
    });
    afterAll(() => {
        loggerErrorSpy.mockRestore();
        loggerDebugSpy.mockRestore();
        loggerWarnSpy.mockRestore();
        loggerLogSpy.mockRestore();
    });

    let controller: GuestEventController;
    let eventService: jest.Mocked<EventService>;
    let timezoneService: jest.Mocked<TimezoneService>;
    let guestDeviceService: jest.Mocked<GuestDeviceService>;
    let deviceFingerprintingService: {
        generateFingerprint: jest.Mock<any, any>;
        ensureDeviceId: jest.Mock<any, any>;
    };
    let eventEnrichmentService: { enrichGuestEventData: jest.Mock<any, any> };

    const mockGuestDeviceService = {
        logger: new Logger('GuestDeviceService'),
        guestDeviceRepository: {},
        findOrCreate: jest.fn(),
        update: jest.fn(),
        findByDeviceId: jest.fn(),
    };

    const mockEventService = {
        create: jest.fn(),
        findAll: jest.fn(),
        findOne: jest.fn(),
        update: jest.fn(),
        guestDeviceService: mockGuestDeviceService,
    };

    const mockTimezoneService = {
        ensureValidTimezone: jest.fn(),
        isValidTimezone: jest.fn(),
        detectTimezoneFromHeaders: jest.fn((headers: Record<string, any>) => {
            if (headers['x-timezone']) {
                return {
                    detectedTimezone: headers['x-timezone'],
                    detectionSource: 'X-Timezone header',
                    headers,
                };
            } else if (headers['accept-language']) {
                return {
                    detectedTimezone: 'America/New_York',
                    detectionSource: 'Accept-Language header',
                    headers,
                };
            } else {
                return {
                    detectedTimezone: 'UTC',
                    detectionSource: 'default',
                    headers,
                };
            }
        }),
        DEFAULT_TIMEZONE: 'UTC',
    };

    const mockResponse = {
        setHeader: jest.fn(),
    } as unknown as Response;

    beforeEach(async () => {
        deviceFingerprintingService = {
            generateFingerprint: jest.fn().mockReturnValue('generated-device-id'),
            ensureDeviceId: jest.fn((deviceId, headers) => {
                if (deviceId) {
                    return { deviceId, isAutogenerated: false };
                } else {
                    return { deviceId: 'generated-device-id', isAutogenerated: true };
                }
            }),
        };
        eventEnrichmentService = {
            enrichGuestEventData: jest.fn(),
        };
        const module: TestingModule = await Test.createTestingModule({
            controllers: [GuestEventController],
            providers: [
                { provide: EventService, useValue: mockEventService },
                { provide: TimezoneService, useValue: mockTimezoneService },
                { provide: DeviceFingerprintingService, useValue: deviceFingerprintingService },
                { provide: EventEnrichmentService, useValue: eventEnrichmentService },
            ],
        }).compile();

        controller = module.get<GuestEventController>(GuestEventController);
        eventService = module.get(EventService);
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    it('should be defined', () => {
        expect(controller).toBeDefined();
    });

    describe('create', () => {
        const mockCreateEventDto: CreateEventDto = {
            name: 'Test Event',
            description: 'Test Description',
            timezone: 'Asia/Ho_Chi_Minh',
            date: '2025-05-01T09:00:00.000Z',
            category: EventCategory.PERSONAL,
            isRecurring: false,
            deviceId: '',
            sourceDeviceId: '',
            notificationSettings: {
                reminders: [0, 1, 7],
                enabled: true,
            },
        };

        it('should create event with provided device ID (not autogenerated)', async () => {
            const deviceId = 'test-device-id';
            const headers = { 'x-timezone': 'Asia/Ho_Chi_Minh' };
            mockEventService.create.mockResolvedValueOnce({ id: '1', ...mockCreateEventDto });

            // ensureDeviceId returns { deviceId, isAutogenerated: false }
            deviceFingerprintingService.ensureDeviceId.mockReturnValueOnce({
                deviceId,
                isAutogenerated: false,
            });

            const result = await controller.create(
                deviceId,
                headers,
                mockCreateEventDto,
                mockResponse,
            );

            expect(deviceFingerprintingService.ensureDeviceId).toHaveBeenCalledWith(
                deviceId,
                headers,
            );
            expect(eventEnrichmentService.enrichGuestEventData).toHaveBeenCalledWith(
                mockCreateEventDto,
                deviceId,
                headers,
            );
            expect(eventService.create).toHaveBeenCalledWith({ deviceId }, mockCreateEventDto);
            // Accept lowercase header name as set by implementation
            expect(mockResponse.setHeader).toHaveBeenCalledWith(
                'x-detected-timezone',
                mockCreateEventDto.timezone,
            );
            // Should NOT set X-Device-ID header if not autogenerated
            expect(mockResponse.setHeader).not.toHaveBeenCalledWith('X-Device-ID', deviceId);
            expect(result).toHaveProperty('id', '1');
        });

        it('should auto-generate device ID when not provided (isAutogenerated = true)', async () => {
            const headers = {
                'user-agent': 'test-agent',
                'x-forwarded-for': 'test-ip',
            };
            mockEventService.create.mockResolvedValueOnce({ id: '3', ...mockCreateEventDto });

            // ensureDeviceId returns { deviceId: 'generated-device-id', isAutogenerated: true }
            deviceFingerprintingService.ensureDeviceId.mockReturnValueOnce({
                deviceId: 'generated-device-id',
                isAutogenerated: true,
            });

            const result = await controller.create('', headers, mockCreateEventDto, mockResponse);

            expect(deviceFingerprintingService.ensureDeviceId).toHaveBeenCalledWith('', headers);
            expect(eventEnrichmentService.enrichGuestEventData).toHaveBeenCalledWith(
                mockCreateEventDto,
                'generated-device-id',
                headers,
            );
            expect(eventService.create).toHaveBeenCalledWith(
                { deviceId: 'generated-device-id' },
                mockCreateEventDto,
            );
            // Accept lowercase header names as set by implementation
            expect(mockResponse.setHeader).toHaveBeenCalledWith(
                'x-device-id',
                'generated-device-id',
            );
            expect(mockResponse.setHeader).toHaveBeenCalledWith(
                'x-detected-timezone',
                mockCreateEventDto.timezone,
            );
            expect(result).toHaveProperty('id', '3');

            await controller.create('', headers, mockCreateEventDto, mockResponse);

            expect(deviceFingerprintingService.ensureDeviceId).toHaveBeenCalledWith('', headers);
            expect(eventEnrichmentService.enrichGuestEventData).toHaveBeenCalledWith(
                mockCreateEventDto,
                'generated-device-id',
                headers,
            );
            expect(mockResponse.setHeader).toHaveBeenCalledWith(
                'x-device-id',
                'generated-device-id',
            );
            expect(mockResponse.setHeader).toHaveBeenCalledWith(
                'x-detected-timezone',
                mockCreateEventDto.timezone,
            );
        });

        it('should throw BadRequestException on error', async () => {
            const deviceId = 'test-device-id';
            deviceFingerprintingService.ensureDeviceId.mockReturnValueOnce({
                deviceId,
                isAutogenerated: false,
            });
            mockEventService.create.mockRejectedValueOnce(new Error('Test error'));

            await expect(
                controller.create(deviceId, {}, mockCreateEventDto, mockResponse),
            ).rejects.toThrow(BadRequestException);
        });

        it('should use ensureDeviceId for device ID logic (default values)', async () => {
            const headers = {};
            mockEventService.create.mockResolvedValueOnce({ id: '2', ...mockCreateEventDto });
            deviceFingerprintingService.ensureDeviceId.mockReturnValueOnce({
                deviceId: 'generated-device-id',
                isAutogenerated: true,
            });
            await controller.create('', headers, mockCreateEventDto, mockResponse);
            expect(deviceFingerprintingService.ensureDeviceId).toHaveBeenCalledWith('', headers);
            // Accept lowercase header names as set by implementation
            expect(mockResponse.setHeader).toHaveBeenCalledWith(
                'x-device-id',
                'generated-device-id',
            );
        });
    });

    describe('findAll', () => {
        const deviceId = 'test-device-id';
        const queryParams = {
            startDate: '2025-05-01T00:00:00.000Z',
            endDate: '2025-05-30T23:59:59.999Z',
            category: EventCategory.PERSONAL,
            timezone: 'Asia/Ho_Chi_Minh',
        };

        it('should return all events for a device', async () => {
            const mockEvents = [{ id: '1', name: 'Test Event' }];
            mockEventService.findAll.mockResolvedValueOnce(mockEvents);

            const result = await controller.findAll(
                deviceId,
                queryParams.startDate,
                queryParams.endDate,
                queryParams.category,
                queryParams.timezone,
            );

            expect(eventService.findAll).toHaveBeenCalledWith({ deviceId }, queryParams);
            expect(result).toEqual(mockEvents);
        });

        it('should throw BadRequestException when deviceId is not provided', async () => {
            await expect(
                controller.findAll(
                    '',
                    queryParams.startDate,
                    queryParams.endDate,
                    queryParams.category,
                    queryParams.timezone,
                ),
            ).rejects.toThrow(BadRequestException);
        });
    });

    describe('findOne', () => {
        const deviceId = 'test-device-id';
        const eventId = 'test-event-id';

        it('should return a single event', async () => {
            const mockEvent = { id: eventId, name: 'Test Event' };
            mockEventService.findOne.mockResolvedValueOnce(mockEvent);

            const result = await controller.findOne(deviceId, eventId, 'Asia/Ho_Chi_Minh');

            expect(eventService.findOne).toHaveBeenCalledWith({ deviceId }, eventId);
            expect(result).toEqual(mockEvent);
        });

        it('should throw BadRequestException when deviceId is not provided', async () => {
            await expect(controller.findOne('', eventId, 'Asia/Ho_Chi_Minh')).rejects.toThrow(
                BadRequestException,
            );
        });
    });

    describe('update', () => {
        const deviceId = 'test-device-id';
        const eventId = 'test-event-id';
        const mockUpdateEventDto: CreateEventDto = {
            name: 'Updated Event',
            description: 'Updated Description',
            timezone: 'Asia/Ho_Chi_Minh',
            date: '2025-05-01T09:00:00.000Z',
            category: EventCategory.PERSONAL,
            isRecurring: false,
            deviceId: '',
            sourceDeviceId: '',
            notificationSettings: {
                reminders: [0, 1, 7],
                enabled: true,
            },
        };

        it('should update an event', async () => {
            const headers = { 'x-timezone': 'Asia/Ho_Chi_Minh' };
            const mockUpdatedEvent = { id: eventId, ...mockUpdateEventDto };
            mockEventService.update.mockResolvedValueOnce(mockUpdatedEvent);

            const result = await controller.update(deviceId, headers, eventId, mockUpdateEventDto);

            expect(eventEnrichmentService.enrichGuestEventData).toHaveBeenCalledWith(
                mockUpdateEventDto,
                deviceId,
                headers,
            );
            expect(eventService.update).toHaveBeenCalledWith(
                { deviceId },
                eventId,
                mockUpdateEventDto,
            );
            expect(result).toEqual(mockUpdatedEvent);
        });

        it('should throw BadRequestException when deviceId is not provided', async () => {
            await expect(controller.update('', {}, eventId, mockUpdateEventDto)).rejects.toThrow(
                BadRequestException,
            );
        });

        it('should not overwrite sourceDeviceId if already set', async () => {
            const headers = { 'x-timezone': 'Asia/Ho_Chi_Minh' };
            const dto = { ...mockUpdateEventDto, sourceDeviceId: 'other-device' };
            const mockUpdatedEvent = { id: eventId, ...dto };
            mockEventService.update.mockResolvedValueOnce(mockUpdatedEvent);
            const result = await controller.update(deviceId, headers, eventId, dto);
            expect(eventEnrichmentService.enrichGuestEventData).toHaveBeenCalledWith(
                dto,
                deviceId,
                headers,
            );
            expect(result).toEqual(mockUpdatedEvent);
            expect(eventService.update).toHaveBeenCalledWith({ deviceId }, eventId, dto);
        });

        it('should throw NotFoundException if eventService.update throws it', async () => {
            const headers = { 'x-timezone': 'Asia/Ho_Chi_Minh' };
            const notFound = new Error('Not found');
            (notFound as any).name = 'NotFoundException';
            mockEventService.update.mockRejectedValueOnce(notFound);
            await expect(
                controller.update(deviceId, headers, eventId, mockUpdateEventDto),
            ).rejects.toBe(notFound);
        });

        it('should throw BadRequestException for generic errors', async () => {
            const headers = { 'x-timezone': 'Asia/Ho_Chi_Minh' };
            mockEventService.update.mockRejectedValueOnce(new Error('Generic error'));
            await expect(
                controller.update(deviceId, headers, eventId, mockUpdateEventDto),
            ).rejects.toThrow(BadRequestException);
        });
    });

    describe('registerDevice', () => {
        const deviceId = 'test-device-id';
        const mockRegisterDto: RegisterDeviceDto = {
            firebaseToken: 'test-token',
            timezone: 'Asia/Ho_Chi_Minh',
        };

        it('should register a device', async () => {
            mockGuestDeviceService.findOrCreate.mockResolvedValueOnce({
                id: '1',
                deviceId,
                firebaseToken: mockRegisterDto.firebaseToken,
            });

            const result = await controller.registerDevice(deviceId, mockRegisterDto);

            expect(mockGuestDeviceService.findOrCreate).toHaveBeenCalledWith(
                deviceId,
                mockRegisterDto.firebaseToken,
                mockRegisterDto.timezone,
            );
            expect(result).toHaveProperty('id', '1');
        });

        it('should throw BadRequestException when deviceId is not provided', async () => {
            await expect(controller.registerDevice('', mockRegisterDto)).rejects.toThrow(
                BadRequestException,
            );
        });

        it('should throw BadRequestException when firebaseToken is not provided', async () => {
            await expect(
                controller.registerDevice(deviceId, { ...mockRegisterDto, firebaseToken: '' }),
            ).rejects.toThrow(BadRequestException);
        });

        it('should throw BadRequestException if guestDeviceService.findOrCreate throws', async () => {
            mockGuestDeviceService.findOrCreate.mockRejectedValueOnce(new Error('fail'));
            await expect(controller.registerDevice(deviceId, mockRegisterDto)).rejects.toThrow(
                BadRequestException,
            );
        });
    });

    describe('detectTimezone', () => {
        it('should detect timezone from X-Timezone header', async () => {
            const headers = { 'x-timezone': 'Asia/Ho_Chi_Minh' };
            mockTimezoneService.isValidTimezone.mockReturnValue(true);

            const result = await controller.detectTimezone(headers);

            expect(result).toEqual(
                expect.objectContaining({
                    detectionSource: 'X-Timezone header',
                    headers: expect.objectContaining({
                        'x-timezone': 'Asia/Ho_Chi_Minh',
                    }),
                }),
            );
        });

        it('should detect timezone from Accept-Language when no timezone header is present', async () => {
            const headers = { 'accept-language': 'en-US' };
            mockTimezoneService.isValidTimezone.mockReturnValue(false);

            const result = await controller.detectTimezone(headers);

            expect(result).toEqual(
                expect.objectContaining({
                    detectionSource: 'Accept-Language header',
                    headers: expect.objectContaining({
                        'accept-language': 'en-US',
                    }),
                }),
            );
        });

        it('should use default timezone when no valid source is found', async () => {
            const headers = {};
            mockTimezoneService.isValidTimezone.mockReturnValue(false);

            const result = await controller.detectTimezone(headers);

            expect(result).toEqual(
                expect.objectContaining({
                    detectionSource: 'default',
                    defaultTimezone: 'UTC',
                }),
            );
        });

        it('should throw BadRequestException if detectTimezoneFromHeaders throws', async () => {
            mockTimezoneService.detectTimezoneFromHeaders.mockImplementationOnce(() => {
                throw new Error('tz fail');
            });
            await expect(controller.detectTimezone({})).rejects.toThrow(BadRequestException);
        });
    });

    // getHeaderCaseInsensitive tests removed because the method does not exist in the controller
});
