import {
    Controller,
    Get,
    Post,
    Patch,
    Body,
    Param,
    Query,
    Logger,
    BadRequestException,
    Headers,
    Res,
} from '@nestjs/common';
import { Response } from 'express';
import { EventService } from '../../application/services/events/event.service';
import { EventCategory } from '../../domain/entities/event.entity';
import { ApiTags, ApiOperation, ApiResponse, ApiHeader, ApiBody, ApiQuery } from '@nestjs/swagger';
import { RegisterDeviceDto as RegisterDeviceInterface } from '../../application/interfaces/guest/register-device.interface';
import { EventServiceExtended } from '../../application/interfaces/events/event-service-extended.interface';
import { TimezoneService } from '../../shared/services/timezone.service';
import { DeviceFingerprintingService } from '../../shared/services/device-fingerprinting.service';
import { EventEnrichmentService } from '../../shared/services/event-enrichment.service';
import { HTTP_HEADERS } from '../../shared/constants/http-headers';
import { CreateEventDto } from '../dto/event/create-event.dto';
import { RegisterDeviceDto } from '../dto/guest/register-device.dto';
import { EventResponseDto } from '../dto/event/event-response.dto';
import { GuestDeviceResponseDto } from '../dto/guest/guest-device-response.dto';

@ApiTags('guest-events')
@Controller('guest-events')
export class GuestEventController {
    private readonly logger = new Logger(GuestEventController.name);

    constructor(
        private readonly eventService: EventService,
        private readonly timezoneService: TimezoneService,
        private readonly deviceFingerprintingService: DeviceFingerprintingService,
        private readonly eventEnrichmentService: EventEnrichmentService,
    ) {}

    @Post()
    @ApiOperation({
        summary: 'Create a new event for guest user',
        description:
            'Creates a new event for a guest user. If no X-Device-ID is provided, one will be auto-generated and returned in the response headers.',
    })
    @ApiResponse({
        status: 201,
        description: 'Event created successfully',
        type: EventResponseDto,
    })
    @ApiResponse({
        status: 400,
        description: 'Bad request',
        schema: {
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid event data' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiHeader({
        name: 'X-Device-ID',
        description:
            'Unique device identifier for guest users. If not provided, a new device ID will be auto-generated.',
        required: false,
    })
    @ApiHeader({
        name: 'X-Timezone',
        description:
            'Client timezone in IANA format (e.g., "America/New_York"). If not provided, timezone detection will be attempted from Accept-Language header.',
        required: false,
    })
    async create(
        @Headers(HTTP_HEADERS.X_DEVICE_ID) deviceId: string,
        @Headers() headers: Record<string, any>,
        @Body() createEventDto: CreateEventDto,
        @Res({ passthrough: true }) response: Response,
    ) {
        try {
            // Ensure we have a device ID, generating one if needed
            const { deviceId: ensuredDeviceId, isAutogenerated } =
                this.deviceFingerprintingService.ensureDeviceId(deviceId, headers);

            // Update the deviceId with the ensured value
            deviceId = ensuredDeviceId;

            // Enrich the event data with device and timezone information
            this.eventEnrichmentService.enrichGuestEventData(createEventDto, deviceId, headers);

            // Add the deviceId to the response headers if it was auto-generated
            if (isAutogenerated) {
                response.setHeader(HTTP_HEADERS.X_DEVICE_ID, deviceId);
            }

            // Add timezone information to the response headers for client reference
            response.setHeader(HTTP_HEADERS.X_DETECTED_TIMEZONE, createEventDto.timezone);

            return await this.eventService.create({ deviceId }, createEventDto);
        } catch (error) {
            this.logger.error(`Error creating event for guest: ${error.message}`, error.stack);
            throw new BadRequestException(error.message);
        }
    }

    @Get()
    @ApiOperation({ summary: 'Get all events for the guest user' })
    @ApiResponse({
        status: 200,
        description: 'Return all events',
        type: [EventResponseDto],
    })
    @ApiResponse({
        status: 400,
        description: 'Bad request',
        schema: {
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'string',
                    example: 'X-Device-ID header is required for retrieving events',
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiHeader({
        name: 'X-Device-ID',
        description: 'Unique device identifier for guest users. Required for getting events.',
        required: true,
    })
    @ApiHeader({
        name: 'X-Timezone',
        description:
            'Client timezone in IANA format (e.g., "America/New_York"). Used for date conversions.',
        required: false,
    })
    @ApiQuery({
        name: 'startDate',
        required: false,
        description: 'Start date for filtering events (ISO format)',
        example: '2025-05-01T00:00:00.000Z',
    })
    @ApiQuery({
        name: 'endDate',
        required: false,
        description: 'End date for filtering events (ISO format)',
        example: '2025-05-30T23:59:59.999Z',
    })
    @ApiQuery({
        name: 'category',
        required: false,
        enum: EventCategory,
        description: 'Filter by event category',
    })
    @ApiQuery({
        name: 'timezone',
        required: false,
        description: 'Timezone for date conversions',
        example: 'America/New_York',
    })
    async findAll(
        @Headers('X-Device-ID') deviceId: string,
        @Query('startDate') startDate?: string,
        @Query('endDate') endDate?: string,
        @Query('category') category?: EventCategory,
        @Query('timezone') timezone?: string,
    ) {
        if (!deviceId) {
            throw new BadRequestException('X-Device-ID header is required for retrieving events');
        }

        return this.eventService.findAll(
            { deviceId },
            {
                startDate,
                endDate,
                category,
                timezone,
            },
        );
    }

    @Get(':id')
    @ApiOperation({ summary: 'Get a specific event by ID for guest user' })
    @ApiResponse({
        status: 200,
        description: 'Return the event',
        type: EventResponseDto,
    })
    @ApiResponse({
        status: 404,
        description: 'Event not found',
        schema: {
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: { type: 'string', example: 'Event not found' },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: 400,
        description: 'Bad request',
        schema: {
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'X-Device-ID header is required' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiHeader({
        name: 'X-Device-ID',
        description:
            'Unique device identifier for guest users. Required for getting a specific event.',
        required: true,
    })
    @ApiHeader({
        name: 'X-Timezone',
        description:
            'Client timezone in IANA format (e.g., "America/New_York"). Used for date conversions.',
        required: false,
    })
    @ApiQuery({
        name: 'timezone',
        required: false,
        description: 'Timezone for date conversions',
        example: 'America/New_York',
    })
    async findOne(
        @Headers(HTTP_HEADERS.X_DEVICE_ID) deviceId: string,
        @Param('id') id: string,
        @Query('timezone') timezone?: string,
    ) {
        if (!deviceId) {
            throw new BadRequestException('X-Device-ID header is required');
        }

        return this.eventService.findOne({ deviceId }, id);
    }

    @Patch(':id')
    @ApiOperation({ summary: 'Update a specific event for guest user' })
    @ApiResponse({
        status: 200,
        description: 'Event updated successfully',
        type: EventResponseDto,
    })
    @ApiResponse({
        status: 404,
        description: 'Event not found',
        schema: {
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: { type: 'string', example: 'Event not found for this device' },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: 400,
        description: 'Bad request',
        schema: {
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid event data' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiHeader({
        name: 'X-Device-ID',
        description: 'Unique device identifier for guest users. Required for updating an event.',
        required: true,
    })
    @ApiHeader({
        name: 'X-Timezone',
        description:
            'Client timezone in IANA format (e.g., "America/New_York"). Used for date conversions.',
        required: false,
    })
    async update(
        @Headers(HTTP_HEADERS.X_DEVICE_ID) deviceId: string,
        @Headers() headers: Record<string, any>,
        @Param('id') id: string,
        @Body() updateEventDto: CreateEventDto,
    ) {
        if (!deviceId) {
            throw new BadRequestException('X-Device-ID header is required');
        }

        try {
            // Enrich the event data with device and timezone information
            await this.eventEnrichmentService.enrichGuestEventData(
                updateEventDto,
                deviceId,
                headers,
            );

            return await this.eventService.update({ deviceId }, id, updateEventDto);
        } catch (error) {
            this.logger.error(`Error updating event for guest: ${error.message}`, error.stack);
            if (error.name === 'NotFoundException') {
                throw error;
            }
            throw new BadRequestException(error.message);
        }
    }

    @Post('register-device')
    @ApiOperation({ summary: 'Register a guest device or update its Firebase token' })
    @ApiResponse({
        status: 200,
        description: 'Device registered successfully',
        type: GuestDeviceResponseDto,
    })
    @ApiResponse({
        status: 400,
        description: 'Bad request',
        schema: {
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Firebase token is required' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiHeader({
        name: HTTP_HEADERS.X_DEVICE_ID,
        description: 'Unique device identifier for guest users. Required for device registration.',
        required: true,
    })
    @ApiHeader({
        name: HTTP_HEADERS.X_TIMEZONE,
        description:
            'Client timezone in IANA format (e.g., "America/New_York"). Used for setting the device timezone.',
        required: false,
    })
    @ApiBody({
        type: RegisterDeviceDto,
        description: 'Device registration details including Firebase token for push notifications',
    })
    async registerDevice(
        @Headers(HTTP_HEADERS.X_DEVICE_ID) deviceId: string,
        @Body() registerDto: RegisterDeviceInterface,
    ) {
        if (!deviceId) {
            throw new BadRequestException('X-Device-ID header is required');
        }

        if (!registerDto.firebaseToken) {
            throw new BadRequestException('Firebase token is required');
        }

        try {
            const { guestDeviceService } = this.eventService as unknown as EventServiceExtended;
            return await guestDeviceService.findOrCreate(
                deviceId,
                registerDto.firebaseToken,
                registerDto.timezone,
            );
        } catch (error) {
            throw new BadRequestException(error.message);
        }
    }

    @Get('detect-timezone')
    @ApiOperation({
        summary: 'Test endpoint to detect client timezone',
        description:
            'Returns detailed information about timezone detection based on request headers.',
    })
    @ApiResponse({
        status: 200,
        description: 'Timezone detection information',
        schema: {
            properties: {
                detectedTimezone: { type: 'string', example: 'Asia/Ho_Chi_Minh' },
                detectionSource: { type: 'string', example: 'X-Timezone header' },
                headers: {
                    type: 'object',
                    description: 'Relevant headers that were used for detection',
                },
                defaultTimezone: { type: 'string', example: 'UTC' },
            },
        },
    })
    @ApiHeader({
        name: HTTP_HEADERS.X_TIMEZONE,
        description: 'Client timezone in IANA format (e.g., "America/New_York")',
        required: false,
    })
    async detectTimezone(@Headers() headers: Record<string, any>) {
        try {
            const detectionResult = this.timezoneService.detectTimezoneFromHeaders(headers);
            return {
                ...detectionResult,
                defaultTimezone: this.timezoneService.DEFAULT_TIMEZONE,
            };
        } catch (error) {
            this.logger.error(`Error detecting timezone: ${error.message}`, error.stack);
            throw new BadRequestException(error.message);
        }
    }
}
